\chapter{Data Analysis and Statistics}

\section{Numpy}

\dfn[]{Numpy}{
    Numpy is a fundamental package for scientific computing in Python.
    It provides support for arrays, matrices, and many mathematical functions to operate on these data structures efficiently.
}

\subsection{Shape, rank, and size}

\begin{lstlisting}[caption={Shape, rank, and size}]
    c = np.array([1, 2, 3, 4])  # Create a 1D array
    print(type(c))  # Output: <class 'numpy.ndarray'>

    b = np.array([[1, 2, 3], [4, 5, 6]])  # Create a 2D array
    shape = b.shape  # Output: 2, 3
    rank = np.ndim(b)  # Output: 2
    size = b.size  # Output: 6
\end{lstlisting}

\subsection{Maniputating arrays}

\textbf{Reshaping arrays} means changing the shape of an array.
The shape of an array is the number of elements in each dimension.
By reshaping, we can add or remove dimensions or change number of elements in each dimension.

\begin{lstlisting}[caption={Reshaping an array}]
    arr = np.array([4, 4, 3, 4, 5, 6, 7, 9, 0, 10, 17, 12])
    newarr = arr.reshape(3, 4)  # Reshape to 3 rows and 4 columns
    print(newarr)
    # Output:
    # [[ 4  4  3  4]
    #  [ 5  6  7  9]
    #  [ 0 10 17 12]]
\end{lstlisting}

We can also access an array element and change value to an array.

\begin{lstlisting}[caption={Accessing and changing array elements}]
    a = np.array([10, 20, 30, 40, 50])
    a[2] = 50  # Change the third element to 50
    print(a)  # Output: [10 20 50 40 50]
\end{lstlisting}

\begin{lstlisting}[caption={Creating special arrays}]
    a = np.zeros((2,2))  # Create a 2x2 array of zeros
    b = np.ones((3,3))   # Create a 3x3 array of ones
    c = np.full((2,3), 7)  # Create a 2x3 array filled with 7s
    d = np.eye(3)    # Create a 3x3 identity matrix
\end{lstlisting}

\textbf{Joining NumPy arrays} means putting contents of two or more arrays into a single array.

\begin{lstlisting}[caption={Joining NumPy arrays}]
    a = np.array([1, 2, 3])
    b = np.array([4, 5, 6])

    c = np.concatenate((a, b))  # Join a and b
    print(c)  # Output: [1 2 3 4 5 6]

    d = np.stack((a, b), axis=0)  # Stack a and b vertically
    print(d)
    # Output:
    # [[1 2 3]
    #  [4 5 6]]

    e = np.stack((a, b), axis=1)  # Stack a and b horizontally
    print(e)
    # Output:
    # [[1 4]
    #  [2 5]
    #  [3 6]]
\end{lstlisting}

\begin{lstlisting}[caption={Slicing NumPy arrays}]
    a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
    print(a)
    # Output:
    # [[ 1  2  3  4]
    #  [ 5  6  7  8]
    #  [ 9 10 11 12]]

    b = a[:3, 1:3]  # Slicing rows 0-2 and columns 1-2
    print(b)
    # Output:
    # [[ 2  3]
    #  [ 6  7]
    #  [10 11]]
\end{lstlisting}

\pr[]{Slicing arrays}{
    b[0, 0] = 20\\
    What happens to array a?

    \textbf{Answer:} Array a is also changed because b is a view of a.
}

\pr[]{Slicing arrays}{
    How to get a copy of a slice of an array so that changes to the slice do not affect the original array?

    \textbf{Answer:} Use the .copy() method to create a copy of the slice.
}

\begin{lstlisting}[caption={Creating a copy of a slice}]
    b = a[:3, 1:3].copy()  # Create a copy of the slice
    b[0, 0] = 20  # Change the first element of b
    print(a)  # Array a remains unchanged
    # Output:
    # [[ 1  2  3  4]
    #  [ 5  6  7  8]
    #  [ 9 10 11 12]]
\end{lstlisting}

\subsection{Handling indexes}

\begin{lstlisting}[caption={Fancy indexing}]
    a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
    print(a)
    # Output:
    # [[ 1  2  3]
    #  [ 4  5  6]
    #  [ 7  8  9]
    #  [10 11 12]]

    b = np.array([0, 2, 0, 1])
    print(a[np.arange(4), b])  # Access elements using array of indices
    # Output: [ 1  6  7 11]

    a[np.arange(4), b] += 10  # Increment selected elements by 10
    print(a)
    # Output:
    # [[11  2  3]
    #  [ 4  5 16]
    #  [17  8  9]
    #  [10 21 12]]
\end{lstlisting}

\begin{lstlisting}[caption={Boolean indexing}]
    b = 1
    b += 10
    print(b)  # Output: 11

    b = 1
    b = b+10
    print(b)  # Output: 11
\end{lstlisting}

\begin{lstlisting}[caption={Searching arrays}]
    grades = np.array([14, 12, 13, 14, 15, 14, 14])
    x = np.where(grades == 14)  # Find indices where grades are 14
    print(x)  # Output: (array([0, 3, 5, 6]),)
\end{lstlisting}

\subsection{Random}

\dfn[]{Random}{
    Random number does not mean a different number each time.
    Random means something that cannot be predicted logically.
}

\begin{lstlisting}[caption={Generating random numbers}]
    from numpy import random

    # Generating random numbers within an array
    e = np.random.random((4, 4)) # Create a 4x4 array of random floats in [0.0, 1.0)

    # Generating random numbers
    x = random.randint(100)  # Generate a random integer from 0 to 99

    # Generating arrays of random numbers
    x = random.randint(100, size=(5)) # Generate an array of 5 random integers from 0 to 99
    x = random.randint(100, size=(3, 4)) # Generate a 3x4 array of random integers from 0 to 99
    x = random.rand(5)  # Generate an array of 5 random floats in [0.0, 1.0)
\end{lstlisting}

\dfn[]{Random data distribution}{
    A random distribution is a set of random numbers that follow a certain probability density function (PDF).
}

\begin{itemize}
    \item Normal distribution (random.normal)
    \begin{itemize}
        \item loc: (mean) where the peak of the bell curve is located
        \item scale: (standard deviation) how flat and wide the bell curve is
        \item size: output shape
    \end{itemize}
    \item Binomial distribution (random.binomial)
    \begin{itemize}
        \item n: number of trials
        \item p: probability of success on each trial
        \item size: output shape
    \end{itemize}
\end{itemize}

\begin{lstlisting}[caption={Generating random numbers from different distributions}]
    # Normal Distribution
    x = random.normal(loc=0.0, scale=1.0, size=(2,3))  # Generate a 2x3 array of random numbers from a normal distribution
    print(x)
    # Output:
    # [[ 0.49671415 -0.1382643   0.64768854]
    #  [ 1.52302986 -0.23415337 -0.23413696]]

    # Binomial Distribution
    x = random.binomial(n=10, p=0.5, size=(3,4))  # Generate a 3x4 array of random numbers from a binomial distribution
    print(x)
    # Output:
    # [[5 6 4 3]
    #  [4 7 6 4]
    #  [6 3 5 4]]
\end{lstlisting}

\section{Pandas}

\dfn[]{DataFrame}{
    Labelled data structure with columns of potentially different types.
    Like a spreadsheet or SQL table, or a dict of Series objects.
}

\begin{lstlisting}[caption={Creating and manipulating a DataFrame}]
    d = {
        'col1': [1,2,1,3,1,2],
        'col2': [1,2,3,4,5,6]
        }
    df = pd.DataFrame(data=d)

    df.count() # Count non-NA cells for each column
    df['col1'].value_counts() # Count unique values in col1
    df['col1'][1] = 5 # Change value in col1 at index 1 to 5
\end{lstlisting}

\pr[]{Copy DataFrames}{
    col1 = df['col1'] \# Accessing a single column\\
    col1[2] = 99\\
    What is the result in col1 and df?

    \textbf{Answer:} Both col1 and df are changed because col1 is a view of df.
}

\pr[]{Copy DataFrames}{
    new\_col1 = col1.copy()\\
    new\_col[2] = 9999\\

    What is the result in new\_col1 and df?

    \textbf{Answer:} Only new\_col1 is changed, df remains unchanged because new\_col1 is a copy of col1.
}

\begin{lstlisting}[caption={Read and save}]
    df = pd.read_csv('data.csv')  # Read data from a CSV file into a DataFrame
    df.to_csv('output.csv')  # Write DataFrame to a CSV file
\end{lstlisting}

\begin{lstlisting}[caption={DataFrame information}]
    df.head()  # Display the first 5 rows of the DataFrames
    df.info()  # Display a summary of the DataFrame
    df.describe()  # Generate descriptive statistics
    df.columns  # List all column names
\end{lstlisting}

\begin{lstlisting}[caption={Accessing DataFrame elements}]
    df.at(2, 'col1')  # Access a single value for a row/column label pair
    df.iloc[2, 0]  # Access a single value for a row/column pair by integer position
    df.xs(2)  # Returns cross-section (row) at index 2
    df.loc[:, 'col1']  # Access a group of rows and columns by labels or a boolean array
\end{lstlisting}

\ex[]{Access to row and columns}{
    \begin{itemize}
        \item Cells: df.iloc[195][0]
        \item Rows: df.iloc[[195], :]
        \item Columns: df.loc[:, 'col1']
    \end{itemize}
}

\begin{lstlisting}[caption={Copying DataFrames}]
    df1=df2 # Assignment
    copydf = df.copy(deep=False) # Shallow copy
    copydf = df.copy(deep=True)  # Deep copy
\end{lstlisting}

\begin{lstlisting}[caption={Data cleaning and conversion}]
    # Convert column to numeric, setting errors to NaN
    df['GDP'] = pd.to_numeric(df['GDP'], errors='coerce')

    # Suppose you have , instead of . in the numbers
    df['GDP'] = df['GDP'].str.replace(',', '.')

    # Suppose you have $ or € symbols in the numbers
    df['GDP'] = df['GDP'].str.replace('$', '', regex=True).str.replace('€', '', regex=True)

    # Drop rows with any NaN values
    df.dropna(inplace=True)
\end{lstlisting}

\begin{lstlisting}[caption={Statistical methods}]
    X.mean()  # Calculate mean of each column
    X.median()  # Calculate median of each column
    X.mode()  # Calculate mode of each column
    X.std()  # Calculate standard deviation of each column
    X.var()  # Calculate variance of each column
    X.corr()  # Calculate correlation matrix
    X.cov()  # Calculate covariance matrix
    X.max()  # Calculate maximum of each column
    X.min()  # Calculate minimum of each column
    X.kurt()  # Calculate kurtosis of each column
    X.skew()  # Calculate skewness of each column
\end{lstlisting}

\section{Regular Expressions}



%\dfn{Definition Topic}{Definition Statement}
%\thm{Theorem Name}{Theorem Statement}
%\cor[cori]{Corollary Name}{Corollary Statement}
%\lem{Lemma Name}{Lemma Statement}
%\clm{Claim Name}{Claim Statement}
%\ex{Example Name}{Example explained}
%\opn{Open Question Name}{Question Statement}
%\pr{Question Name}{Question Statement}
%\nt{Special Note}
%\wc{Wrong Concept topic}{Explanation}
%\proof{Proof Idea}{}
